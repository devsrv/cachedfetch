<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.20/lodash.min.js"></script>
    <script>
        function _hasTTLExpired(ttl) {
            const currDate = new Date();

            return currDate.getTime() > Number(ttl);
        }
        function _setTTL(no, period = 'minute') {
            const supportedPeriods = ['hour', 'minute', 'second'];

            if(! supportedPeriods.includes(period)) {
                throw new Error('period not supported, use any of hour/ minute/ second');
            }

            const till = Number(no);

            const currDate = new Date();

            switch (period) {
                case 'hour':
                    currDate.setHours(currDate.getHours() + till);
                    break;
            
                case 'minute':
                    currDate.setMinutes(currDate.getMinutes() + till);
                    
                    break;
            
                default:
                    currDate.setSeconds(currDate.getSeconds() + till);
                    break;
            }

            return currDate.getTime();
        }
        const _hashstr = s => {
            let hash = 0;
            if (s.length == 0) return hash;
            for (let i = 0; i < s.length; i++) {
                let char = s.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash;
        }

        const storageBox = (driver = 'localStorage', disk = undefined) => {
            let storage = window.localStorage;

            switch (driver) {
                case 'localStorage':
                    storage = window.localStorage;
                    return {
                        get: (key) => storage.getItem(key),
                        set: (key, val) => storage.setItem(key, val),
                        remove: (key) => storage.removeItem(key),
                        clear: () => storage.clear(),
                    }

                    break;
            
                case 'sessionStorage':
                    storage = window.sessionStorage;
                    return {
                        get: (key) => storage.getItem(key),
                        set: (key, val) => storage.setItem(key, val),
                        remove: (key) => storage.removeItem(key),
                        clear: () => storage.clear(),
                    }

                    break;
            
                case 'AsyncStorage':
                    if (typeof disk === 'undefined') {
                        throw new Error('required storage instance missing');
                    }

                    return {
                        get: async (key) => {
                            try {
                                const value = await disk.getItem(key)
                                return value;
                            } catch(e) {
                                throw new Error('error reading value from '+ driver);
                            }
                        },
                        set: (key, val) => disk.setItem(key, val),
                        remove: async (key) => {
                            try {
                                await disk.removeItem(key)
                            } catch(e) {
                                throw new Error('error removing data from '+ driver);
                            }
                        },
                        clear: () => disk.clear(),
                    }

                    break;
            
                default:
                    storage = window.localStorage;
                    return {
                        get: (key) => storage.getItem(key),
                        set: (key, val) => storage.setItem(key, val),
                        remove: (key) => storage.removeItem(key),
                        clear: () => storage.clear(),
                    }
            }
        }

        const cacheManager = (config, key, url, overrideCachemode = null) => {
            if(! _.has(config, 'mode') || ! ['block', 'allow'].includes(config.mode)) throw new Error('accepted modes: block | allow');
            if(! _.has(config, 'matchIn') && ! _.has(config, 'endsWith')) throw new Error('malformed config');

            const storage = storageBox(config.driver, config.disk);
            const cacheKey = _hashstr(`${key}:${url}`);

            return {
                should: function() {
                    if(overrideCachemode !== null) return overrideCachemode;

                    let allowed = false;

                    if(config.mode === 'block') {
                        allowed = true;

                        if(_.has(config, 'matchIn')) {
                            if(config.matchIn.includes(url)) allowed = false;
                        }

                        if(_.has(config, 'endsWith')) {
                            config.endsWith.forEach(partial => {
                                if(_.endsWith(url, partial)) allowed = false;
                            });
                        }
                    }
                    else {
                        allowed = false;

                        if(_.has(config, 'matchIn')) {
                            if(config.matchIn.includes(url)) allowed = true;
                        }

                        if(_.has(config, 'endsWith')) {
                            config.endsWith.forEach(partial => {
                                if(_.endsWith(url, partial)) allowed = true;
                            });
                        }
                    }

                    return allowed;
                },
                has: function(item) {
                    if(item === null) return false;

                    const payload = JSON.parse(item);

                    if(_hasTTLExpired(payload.ttl)) {
                        this.delete();

                        return false;
                    }

                    return true;
                },
                store: function(data, ttlStr = config.defaultTTL) {
                    console.log('should store', this.should());

                    if(! this.should()) return false;

                    const ttlParts = ttlStr.split(' ');
                    const ttl = _setTTL(ttlParts[0], ttlParts[1]);

                    storage.set(cacheKey, JSON.stringify(Object.assign({
                        data,
                        ttl
                    })));

                    console.log('stored for ', ttlStr);
                },
                get: function() {
                    return storage.get(cacheKey);
                },
                select: function() {
                    if(overrideCachemode !== null) {
                        if(overrideCachemode === false) {
                            this.delete();

                            return false;
                        }
                    }

                    const item = this.get();

                    if(! this.has(item)) return false;

                    return JSON.parse(item).data;
                },
                delete: () => {
                    storage.remove(cacheKey);
                },
                flushAll: () => {
                    storage.clear();
                },
            }
        }

        function cachedFetch(key, url, userOptions) {
            const config = {
                mode: 'block',
                matchIn: [
                    'https://jsonplaceholder.typicode.com/posts/1'
                ],
                endsWith: [
                    '?postId=1',
                    // '/posts'
                ],
                defaultTTL: '5 minute',
                driver: 'sessionStorage',
                disk: undefined
            }

            const headers = new Headers();
            headers.append('Accept', 'application/json');
            headers.append('Content-Type', 'application/json');
            headers.append('X-Requested-With', 'XMLHttpRequest');
            // headers.append('X-CSRF-Token', document.querySelector('meta[name="csrf-token"]').content);

            let options = {
                headers: headers
            };

            options = Object.assign(options, userOptions);

            let overrideCachemode = null;
            if(_.has(options, 'keep-cache')) {
                overrideCachemode = options['keep-cache'];
            }

            const cacher = cacheManager(config, key, url, overrideCachemode);

            const cachedContent = cacher.select();

            // cached data exists, resturning cached
            if(cachedContent) {
                console.log('fetching cached');

                const response = new Response(cachedContent)
			    return Promise.resolve(response)
            }

            console.log('no cached content');

            // nothing in cache store, fetch & cache, then response out
            return fetch(url, options).then(response => {
                // let's only store in cache if the content-type is 
                // JSON or something non-binary
                if (response.status >= 200 && response.status < 300) {
                    let ct = response.headers.get('Content-Type')
                    if (ct && (ct.match(/application\/json/i) || ct.match(/text\//i))) {
                        // There is a .json() instead of .text() but 
                        // we're going to store it in sessionStorage as 
                        // string anyway.
                        // If we don't clone the response, it will be 
                        // consumed by the time it's returned. This 
                        // way we're being un-intrusive. 
                        response.clone().text().then(content => {
                            let ttl = _.has(options, 'cacheTTL') ? options.cacheTTL : config.defaultTTL;

                            console.log('attempt storing');
                            cacher.store(content, ttl);
                        })
                    }
                }
                return response
            })
        }

        (function() {
            // ex - 1
            cachedFetch('fetch_posts', 'https://jsonplaceholder.typicode.com/posts', {
                'keep-cache' : true,
                cacheTTL: '1 minute'
            })
            .then(r => r.json())
            .then(res => console.log('result', res));

            // ex - post
            /*cachedFetch('add_user', 'https://reqres.in/api/users', {
                method: 'POST',
                body: JSON.stringify({name: 'sourav', job: 'engineer'}),
                'keep-cache' : false,
                // cacheTTL: '1 minute'
            })
            .then(r => r.json())
            .then(res => console.log('result', res));*/

            // ex - 2
            /*cachedFetch('fetch_posts', 'https://httpbin.org/html', {
                'keep-cache' : true,
                cacheTTL: '1 minute'
            })
            .then(r => r.text())
            .then(res => console.log('result', res));*/
        })();
    </script>
    
</body>
</html>